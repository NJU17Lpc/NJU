## 一、事务

#### 1、什么是事务

- 某个用户所执行的一个不能被打断的对数据库的操作序列
- （从而数据库系统可以提供相关保障）
- （开始一个事务：就是第一个数据库操作开始）
- （结束一个事务有两种）
  - ecec sql **commit** work
  - exec sql **rollback** work
- 做了两件事
  - 从数据库中返回信息
  - 通过更新数据库来反映现实世界中的事件

#### 2、事务的设计需要处理哪些额外的问题

- 处理一个非连续结果：转账信息还没写入磁盘，电脑坏了
- 并发操作导致错误
- 数据库信息一直在变化而引发的不确定性
- 于是事务需要满足ACID性质

#### 3、事务的性质有哪些

- 原子性Atomicity：一个事务中，所有数据库访问操作构成一个**不可分割**的序列。要么全部执行结束，要么一个都不执行
  - （**事务管理**子系统、事务日志，负责）
- 一致性Consistency：一个事务的成功执行总是将数据库从一个**一致的状态**转换**到另一个一致的状态**
  - （DBMS“数据库**完整性保护**”子系统，编写事务的应用程序员，保证）
- 隔离性Isolation：一个事务的执行，与并发执行的其他事务之间，**相互独立、互不干扰**
  - （DBMS**并发控制**子系统，来实现）
- 持久性Durability：一个事务完成全部操作后，它对数据库的所有更新应**永久反映**在数据库中，即使以后系统发生故障，也能通过**故障恢复**来保留这个事务的执行结果
  - （DBMS**恢复管理**子系统，来实现）

#### 4、调度器做了什么

- 调度器保证历史指令序列的效果，等价于某种串行调度
  - 可能延迟一些操作，或者abort某些事务
- （注意，每个transaction会包括多个R\W操作）

#### 5、什么是可串行化调度？

- 事务的操作序列等价于一个串行调度

怎么保证

- 冲突动作定义
  - 两个操作是冲突的，当且仅当下面三个条件成立
    - 访问相同数据对象
    - 是不同的事务发出的操作
    - 两个操作中有一个是写
- 怎么解释说明一个经历(history) H
  - 说明经历中，各个事务的目的；比如T1在做从A到B的转账工作
  - 写出读写操作具体的值
  - 一致性规则：事务执行过程中必须保持的某种逻辑；例如转账不会改变钱的总数目
- 前驱图：precedence graph
  - 是一个有向图
    - 顶点是**已经COMMITED的事务**
    - 边Ti->Tj表示任何等价串行经历中，i必须在j前面
  - **<u>经历H有一个等价的串行经历S(H)，当且仅当对应的前驱图PG(H)中不存在环</u>**

#### 6、怎么保证Serializability

- 封锁
  - 引入：一个事务访问数据库中的数据时，必须先获得**被访问数据对象**上的**封锁**，保证访问操作的正确性与一致性
  - 作用：一段时间内**禁止**其他事务，在被封锁的数据对象上，执行**某些类型的操作**；也表明持有这个锁的事务，在被封锁的数据对象上，**执行**什么**类型操作**
  - 类型
    - 排它锁(X锁 eXclusive)--写封锁
      - 数据对象没有其他封锁时，事务T才能施加X锁
      - 事务T施加X锁后，其他任何事务都不能加任何锁
      - （独占，维持到事务结束，降低并行性）
    - 共享锁(S锁 Sharing)--读封锁
      - 数据对象没有其他事务封锁，or，其他事务只是S锁。当前事务T才能加S锁
      - （共存，不必维持到结束，提高并发性）
- 合适事务
  - 一个事务在访问数据库中数据对象A之前，按照要求**申请封锁**；操作**结束之后释放**A上的封锁，这叫**合适事务**
    - 是**保证并发事务正确执行的基本条件**
- 两阶段封锁2PL  三条规则
  - 在Ri(A)前，调度器试图做RLi(A)；在Wi(A)前，调度器试图做WLi(A)
  - 如果冲突，那么请求需要wait
  - 就是说加锁有两个阶段
    - 增长阶段，获得锁
    - 收缩阶段，释放锁
    - 调度器保证：不允许一个事务释放了某个锁之后，又去申请别的锁
- 加锁定理：**遵循2PL原则的事务型操作经历，<u>必定可串行化**</u>
- 注意2PL他并不要求事务必须一次要把所有要使用的数据全部加锁，因此**遵循2PL的事务可能死锁**

#### 7、隔离级别相关

- 每个事务都可以自主选择：自己与其他并发事务之间的隔离级别
- 一个事务所选择的隔离级别，**决定了它在运行过程中（调度器）采用的封锁策略**-----这是为了提升性能
- 四种不同的隔离级别： **SET transaction isolation level**
  - 未提交读 readUncommited：当前事务不申请任何的封锁，可能读到的内容是哪一个“写”还没提交的。**这个级别下，单纯不允许执行写操作。其他级别可以通过X锁来写**。“脏”读。比如计算平均值时，读到了还没更新的数据
  - 提交读 readCommited：读之前需要申请S锁，读操作结束后**立即释放**；避免读未提交的结果；就是**只能读取已提交的数据**
  - 可重复读 readRepeatable：读之前申请S锁，维持到**当前事务结束**；避免其他事务，修改当前使用的数据对象。对比提交读，如果我用一个游标遍历几行数据，若用提交读，两次读之间数据可以改变；而可重复读，**解决一个事务内对某行数据不可重复的异常**
  - 可序列化/可串行化 serializable：可串行化调度实现并发执行；等价于之前的可串行，前面三种要求比较宽松
- 短期锁：在操作前取用，操作后立即释放
- 长期锁：一直等到事务结束释放
- 这边具体的细节目测不用太关注，之前保证可序列化的部分目测重要点

#### 8、事务恢复

- Logs
  - 日志项包括每个事务做的更新操作的
    - before Image和after Image
  - before Image：备份一个还没有到磁盘的update
  - after Image：恢复一个应该到磁盘的数据
  - 三种Logs
    - UNDO Logs：只有before image；恢复还没有commit的事务
    - REDO Logs：只有after image；恢复已经commit的事务
    - UNDO/REDO Logs: before & after image：恢复各种事务 
  - commit的时候，就去把Log Buffer写到Log File
    - 如果Log Buffer满了，也会触发这个写回
- 现在来解决恢复的问题（考虑事务的原子性）
  - 问题1：一些事务还没有完成，就把更新写到磁盘。突然断电了
  - 问题2：一些已经提交了的事务，还没有将更新的数据写回磁盘，突然断电了
  - 恢复的过程：ROLLBACK+ROLLFORWARD
    - ROLLBACK：执行UNDO：撤销不应该发生的更新
      - 已经commit的不动，放入已提交列表；没有commit的把数据状态设为之前，放入未提交列表
    - ROLLFORWARD：执行REDO：完成应该发生的更新
      - 未提交列表的不动，已提交列表的，设置REDO，数据置为修改后的值

#### 9、检查点

- 引入：恢复过程要扫描整个undo日志来做REDO，为了降低故障恢复的开销，可以定期在日志文件中插入“检查点”

- 插入检查点过程

  1. 停止接受启动新事物的请求
  2. 等所有当前活跃的事务commited/abort，并在日志记录
  3. 将日志刷新到磁盘
  4. 在日志中插入检查点记录<CKPT>，并再次刷新日志，则完成这个checkpoint
  5. 重新开始接受新的事务

  故障恢复时，只需要逆向扫描到第一个<CKPT>记录就可以做恢复

  建立检查点的动机，大概就是日志记录项到达一定限制

- 上面这种检查点叫“提交一致检查点”。为了解决一些性能问题，引入更复杂的检查点策略

  - 高速缓存一致性检查点：将内存中磁盘缓冲区运用起来，解决检查点阻塞系统的问题；额外要求主要是：**存在的事务不允许发出新操作**
  - 模糊检查点：减少完成检查点的绝对时间：太复杂真心来不及看





















