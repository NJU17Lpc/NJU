# 5、编程模型

lecture 05  **ppt8 mapReduce简单处理流程; ppt13 多个reducer的处理流程；ppt14 Partition**

**ppt18 JobTracker和TaskTracker；ppt20 基于Yarn Hadoop MR**

- 用于处理海量数据、异构数据
- 希望开发人员将精力集中于业务逻辑，充分利用集群资源，降低编程处理海量数据难度
- 代表编程模型
  - mapReduce: 用于大规模数据处理
  - Dryad: 大规模流式计算
  - Pregel: 大规模图计算

#### MapReduce

- 设计目标：许多CPU并行处理，海量数据，并容易实现
- 思想：分而治之
- 流程：遍历大规模记录--从每个记录抽取中间结果--中间结果排序--排序后集成中间结果--生成最终结果
  - map (in_key, in_value) -> (out_key, intermediate_value) list
  - reduce (out_key, intermediate_value list) -> out_value list

##### 数据分片

- MR的输入数据划分成等长小数据块
- 分片数据较多时，易于负载平衡，处理每个分片时间少于处理整个输入数据时间
- 分片大小过小：管理分片总时间和构建map任务总时间，决定作业执行时间

##### 本地计算

- master根据数据所在位置，分配任务
  - 让map和数据在同一个节点上
  - 至少处于同一个机架
- map处理数据。不大于数据块大小(64MB)
  - 如果分片跨越两个数据块，则可能引起数据传输

##### 中间结果

- map任务结果写入本地硬盘，不是HDFS
  - 中间结果在程序运行结束后删除
  - 存在HDFS浪费资源

##### 容错机制

- master检测出错的worker
  - 重新执行 **完成或进行中**的 map任务（应该是为后续节点容错）
  - 重新执行**进行中的**reduce任务
- master检测到引起Map出错的特定key
  - 重新执行时，忽略这些key

##### 性能优化

- 最慢的map任务会拖慢整个进程
  - reduce需要等到所有Map任务结束后才开始
  - 解决：master将相同的Map任务分配到多个节点进行，以最先完成的为结果
- combine和map在同一个节点上执行
  - 这样的话最后reduce需要处理的数据量降到最低

##### mapReduce优点

- 无共享大规模集群系统，可伸缩性和性价比好
  - 对比高性能计算/网格计算，他们采用的时存储区域网络组织的共享文件结构
- 模型简单，易于理解和使用，支持大多数数据处理问题
- 只提供了一个过程性的编程接口，可以通过合适的查询优化和索引技术，提供好的数据处理性能

#### Hadoop MapReduce

- 基本要求：待处理的数据集  可以分解为  可并行处理的小数据集

- 实现机制：
  - JobTracker和TaskTracer调度：JobTracker负责**<u>调度和管理</u>**TaskTracker
  - 计算和存储共享节点
  - 处理的小数据集不大于HDFS的数据块，因为每台计算机会有多种数据库，于是每台计算机上可以运行多个任务
  - 连接combine和分区partition
    - 合并key相同的中间结果
    - 将连接的结果按照key的范围划分
  - 任务管道
    - reduce的结果可以作为新的输入，不一定合并

- 缺陷

  - JobTracker

    - 是MR集中处理点，会有单点故障

    - mapreduce job非常多的话,JobTracker内存开销大，增加故障风险

  - taskTracker

    - 以task数目作为资源，这种表示过于简单，没有考虑CPU/内存占用情况
    - 如果不小心把两个占用内存大的task放在一起，会内存溢出
    - 把资源强制划分成map task slot和reduce task slot，系统中只有map或者reduce，会造成浪费

  - 代码难以阅读，增加bug和维护难度

  - 框架在进行任何变化时，强制让集群系统每一个用户端更新

- 改进：基于YARN的Hadoop MapReduce

  - 将JobTracker的两个功能：资源管理/任务调度(监控)，分离成单独的组件
    - Resource Manager: 
      - 全局管理所有计算资源的分配，调度、启动、监控每个application master
    - Application Master:
      - 每个job都有一个这样的master，负责job生命期内所有工作
    - Node Manager:
      - 负责container状态维护，向Resource Manager保持心跳

#### 排序

- input--map--partition--merge on disk-------merge-(sort)-merge--reduce--output
- 基于索引树的partition
  - 对每个split取样并排序，取出间隔平均的n-1个样
  - 依据上一步，构建类似于B树的索引树
  - 前缀相同的key，被分配到一个叶子节点；每个叶子节点上可能有多个reducer

#### 单源最短路径

- Dijkstra
- 广度优先
  - mapper: 
    - input: (key: node n, value: distance 和 adjacency list)
    - output: 对adjacency list中任意node p
      - 输出(key: node p, value:distance+Wn-p)
  - reducer:
    - output
      - (key: node p, value: minimum distance of p)

#### 网页倒排索引

- 显示一个二维数组标注，然后像是一个word count,不是很懂

#### 其他计算模型

- 流式计算：storm, kafka
- 内存计算：spark, flink
- 图计算



# 6、虚拟化

#### 什么是虚拟化

- 是表示计算机资源的抽象方法
- 可以简化基础设施、系统和软件等计算机资源的表示、访问、管理
- 为资源提供标准接口来输入输出

#### 特点

- 虚拟化的对象是各种资源
- 虚拟化的逻辑对用户屏蔽不必要的细节
- 在虚拟环境中实现真实环境中的功能

#### 为什么要虚拟化

- 硬件无关性
  - 虚拟服务器需要解决软硬件不兼容问题，要容易迁移
- 服务器整合
  - 允许不同的虚拟服务器共享一个物理服务器，做提高硬件利用率，负载均衡，优化IT资源
- 资源复制
  - 易于创建标准化虚拟机映像（例如虚拟硬件、OS、应用软件），支持瞬时部署
  - 增强迁移和部署虚拟机新实例的灵活性
  - 有利于回滚和业务连续性

#### 1、基础设施虚拟化

- 网络虚拟化：网络硬件和软件资源整合，向用户提供网络连接的虚拟化技术，有局域网虚拟化、广域网虚拟化
- 存储虚拟化：为物理的存储设备提供了抽象的逻辑视图，用户同意同一逻辑接口访问资源，有基于存储设备的存储虚拟化RAID, 基于网络的存储虚拟化SAN

#### 2、软件虚拟化

- 应用虚拟化：操作系统和应用程序解耦合，提供虚拟运行环境；环境中提供了应用的可执行文件和需要的环境
- 高级语言虚拟化：为解决可执行程序，在不同体系结构计算机之间迁移的问题
  - 将高级语言程序  编译为  **标准中间指令**

#### 3、系统虚拟化

- 使用虚拟机管理程序，各个虚拟机在资源占用方面相互隔离，保证安全和稳定

#### 4、系统机管理程序

- Hypervisor
  - 直接运行在硬件上，以类似OS的形式安装在硬件上，I/O优化，主要用于服务器
  - VMware ESX
- 托管类型
  - 安装在传统OS上，性能不如上面，但安装方面、功能丰富
  - VMware Workstation
- 托管模式
  - 物理机OS上，创建的模拟硬件的程序，但速度较慢
  - **<u>客户OS无需修改</u>**
  - 硬件----**OS**----多个硬件VM----客户OS----应用
- 全虚拟化
  - 管理节点  在客户OS和硬件之间  捕捉对虚拟化敏感的  **<u>特权指令</u>**
  - 托管模式和hypervisor都可以有
  - **<u>客户OS无需修改</u>**
  - 速度随具体实现变化，**<u>最成熟最常见</u>**
  - 硬件----虚拟机管理程序----客户OS+管理节点----应用
- 半虚拟化
  - hypervisor
  - 需要在**<u>用户OS上集成半虚拟化相关代码</u>**，实现对底层硬件的共享访问
  - 速度快
- 硬件辅助虚拟化
  - 部分全虚拟化和半虚拟化，将一些软件技术进行硬件化，提高性能
  - 速度更接近物理机，通常不单独使用
- 操作系统级虚拟化
  - 对OS进行修改，来隔离
  - 资源隔离表现比较差
  - 成本低，性能不错

#### 存在问题

- 性能开销
  - 高工作负载，少用资源共享的系统，虚拟化不是好选择
  - 半虚拟化改进开销，但增加复杂的
- 特殊硬件兼容性
  - 特殊硬件  或者最新硬件  没有对应虚拟化软件
- 可移植性
  - 不兼容性导致可移植性问题
  - 有开放虚拟化格式（OVF）来解决这类问题



























