# 第十六章 设计模式

## 1、如何实现可修改性、可扩展性、灵活性

- 可修改性，包含几个方面
  - （狭义）可修改性，是对于已有实现的修改
  - 可扩展性（对新的实现的扩展）
  - 灵活性（对实现的动态配置）
- 为了实现上面的可修改性，需要**将接口与实现分离**（java里面有两种方式）
  - <u>**通过接口，和实现该接口的类，完成接口与实现的分离**</u>
  - <u>**通过子类继承父类，将父类的接口与子类的实现分离**</u>
  - 从而
    - 可修改性：修改对调用代码没有耦合
    - 扩展：创建新的子类实现
    - 灵活：使用多态实现
- 再利用接口的组成关系，在实现接口的前提下，可以实现更好的灵活性
- 很多设计模式，就是大量利用了：上面**<u>两种实现与接口分离的方式</u>**

## 2、策略模式

## 3、抽象工厂模式

#### 问题背景

- 普通工厂模式中，需要用if else判断创建具体类，不能实现多态。耦合性很强
- 不同的车需要由不同的工厂创建，而每个车工厂要组合不同的零件
  - 要求我们对工厂进行抽象

#### 怎么实现

抽象工厂提供两套接口：

- 一个表现出稳定的工厂行为，用来创建不同的工厂
- 一个表现出稳定的产品行为，用来创建不同的产品

#### code

## 4、单件模式

#### 问题背景

- 内存中只希望有唯一一个对象存在
- 每次获得他的引用，都指向唯一的对象
- 这里很多时候要和线程问题相关的，书上只有最简单的实现

#### 怎么实现

- 构造方法私有
- 通过静态getInstance方法获得对象引用

#### code

`public class CommonInstance {`

​	`public Instance a_instance = null;`

​	`public static Instance getInstance(){`

​		`if(a_instance == null){`

​			`a_instance = new Instance();`

​		`}`

​		`return a_instance;`

​	`}`

`}`

## 5、迭代器模式

#### 问题背景

- 只是想要挨个访问某个聚合结构，不希望知道他是LinkedList还是HashSet
- 于是**要对不同的聚合结构，提供一个同一的接口**

#### 怎么实现

- 对遍历操作进行抽象，有两步
  - **是否有下一个元素**
  - **得到下一个元素**
- 迭代器的实现**只提供了对集合访问的方法，屏蔽了对集合修改的方法**
  - 能做到 **按值传递**

#### 其中的原则依据

- 减少耦合
  - **减少遍历的使用类，和遍历的实现类，直接的耦合**
- 依赖倒置
  - 遍历的使用类，**依赖的是策略的接口，而非遍历的实现类**

#### code

`createAggregate(){`	

​	`Collection list = new HashSet();`

​	`iterFunc(c.iterator())`

`}`

`iterFunc(Iterator i){`

​	`while(i.hasNext()){`

​		`doSomeThing(i.next());`

​	`}`	

`}`

## 6、题型

- 给定场景，应用设计模式并写出代码
- 给出代码，要求用设计模式改写