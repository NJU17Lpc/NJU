# 第十五章 详细设计中面向对象方法下的信息隐藏

## 1、信息隐藏

- <u>**模块化设计中（第十三章），信息隐藏主要有（模块需要隐藏的决策）**</u>
  - <u>**职责的实现**</u>
  - <u>**实现的更变**</u>
- <u>**在面向对象方法中**</u>
  - <u>**封装类的职责，隐藏职责的实现**</u>
  - <u>**预计将会发生的变更，抽象他的接口，隐藏他的内部机制**</u>

## 2、封装

### 分离接口与实现

- 接口通常描述以下内容
  - 对象之间交互的信息（方法名）
  - 消息中的参数
  - 消息返回结果的类型
  - 与状态无关的不变量
  - 需要处理的异常

### 封装实现细节

封装需要**隐藏**除了接口以外的，所有实现细节

- 封装数据和行为
  - getter\setter，但是要注意不要单纯地将方法和成员变量一一对应
- 封装内部结构
  - 不要暴露数据结构的实现决策
  - 比如getPosition不要写成getPositionArray
- 封装其他对象的引用
  - 迪米特法则，不要跨层调用
- 封装类型信息
  - 隐藏具体子类型，只需要知道其共性类别
  - LSP就是封装类型信息的典型方法
- 封装潜在变更
  - 如果预计类的实现中，有特定地方会发生变更，就应该将其独立为单独的类或方法
  - 为单独的类或方法，抽象建立稳定的接口
  - 例如Position从原来的经度纬度，变成极坐标表示

## 3、OCP: Open Close Principle 开闭原则

### 内容

- 好的设计应该对扩展开放
- 好的设计应该对修改关闭
- 简单来说，发生变更时，好的设计只需要添加新的代码，而不需要修改原有的代码，就能实现变更

### 使用多态实现OCP

- 对于新增加的需求，可以将其实现代码组织成一个新类型
- 将新类型与程序中某个原有类型联合起来建立堕胎机制



- 对于已有需求的变更，可以将变更后需求的实现代码组织成一个新类型
- 将类型与其原类型联合起来建立多态机制

### 注意，OCP只能保证业务逻辑代码部分不发生修改，而不是所有代码

## 4、DIP: Dependency Inversion Principle 依赖倒置原则

### 耦合的方向性

- 虽然默认耦合时方向无关的
- 但实际情况下，耦合经常是方向相关的
- 因为某个类可能会不稳定，经常发生修改，造成影响
- （所以很多时候耦合的方向很重要，要连接到尽量稳定的部分）

### 依赖倒置原则内容

- 抽象不应该依赖于细节，细节应该依赖于抽象。因为抽象是稳定的，细节是不稳定的
- 高层模块不应该依赖于低层模块，而是双方都依赖于抽象。因为抽象是稳定的，而高层和低层模块都可能是不稳定的
- （DIP就是用于将**方向不佳的耦合转化为方向理想的耦合**，从而DIP帮助减少了耦合）

### DIP的实现

- 在B需要依赖于A的情况下
- 如果A是抽象的，那么  B依赖于A  符合DIP
- 如果A是具体的，那么  B依赖于A  不符合DIP
  - 为A建立抽象接口IA，使用B依赖IA，A实现IA
  - 那么依赖关系将被倒置为  B依赖于IA，A依赖于IA
  - 这两个关系都符合DIP
- 过程总结为：为具体类建立抽象接口，并分离该接口，是实现DIP的基本手段

### 注意 DIP是有代价的，增加了系统的复杂度

- 当有迹象表明，某个行为是不稳定的（需求经常会变）
- 才可以使用DIP
- 强行使用DIP会导致过度的设计



## Principle 10-12

- Minimize The Accessibility of Classes and Members 权限最小化原则
  - 抽象 Abstraction
  - 封装 Encapsulation
- Open/Closed Principle(OCP)
- Dependency Inversion Principle(DIP)